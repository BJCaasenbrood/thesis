
\section{Soft robotics study cases}
\label{sec:C5:studycases}
In the subsequent section, we will delve into the capabilities of the toolkit, \textit{Sorotoki}. To provide a comprehensive overview of the toolkit, various problem scenarios will be considered, each with specific problem settings aimed at the design, modeling, or control of soft robots. We will also focus on widely cited papers in the field of soft robotics and demonstrate these, mostly experimental, works using the \texttt{Sorotoki}.
\begin{rmk}
It is noteworthy that the full code can be accessed in the repository under the folder \texttt{./scripts/paper/}, enabling users of the toolkit to reproduce all presented simulation results in the following section.
\end{rmk}
%
\afterpage{
\begin{figure}[t]
\centering
\vspace{-3mm}
\includegraphics*[width=0.7\textwidth]{./pdf/thesis-figure-6-17.pdf}
%\input{./fig/fig_passivewalker_ref.tex}
\vspace{-1mm}
\caption{Snapsnots of the multi-legged passive walker from Suzumori and Saito \cite{Suzumori2008Sep} can be observed. The soft walker is placed on an inclined surface with a slope of $\varphi = -30\si{\degree}$ and initiates locomotion from an offset in the gravitational potential. These video frames were captured using a high-speed camera.
\label{fig:C5:passivewalker_true}}
\end{figure}
%
\begin{figure}[t]
\centering
%\vspace{-5mm}
\includegraphics*[width=.7\textwidth]{./pdf/thesis-figure-6-18.pdf}
%\input{./fig/fig_passivewalker_soro.tex}
\caption{Snaphots of the multi-legged passive walker from \texttt{Sorotoki}. The experimental setup is similar to that described in \cite{Suzumori2008Sep}. By comparing the gaits in Fig. \ref{fig:C5:passivewalker_true}, a resemblance can be seen between the results obtained in \texttt{Sorotoki} and those reported in \cite{Suzumori2008Sep}. The Von Mises stresses are shown as \protect\colormapcaption{0}{.75cm}$\!\!\in [0,100]$ \si{\mega \pascal}. }
\label{fig:C5:passivewalker_soro}
\end{figure}
\clearpage
}
%
\subsection{Multi-legged soft passive walker}
\label{sec:C5:suzumori_walker}
In the first case study, the \texttt{Sorotoki} toolkit will be used to examine the dynamics of a multi-legged soft passive walker. The work of Suzumori and Saito \cite{Suzumori2008Sep} served as a key source of inspiration for this modeling problem. They proposed using a specialized soft structure that consists of an array of V-shaped soft legs, which exhibit stable intrinsic locomotion when placed on an inclined surface. This behavior was observed in experiments, as shown in Figure \ref{fig:C5:passivewalker_true}. The natural locomotion is driven by the elastic deformations of the V-shaped legs and their interaction with the environment, and is propelled forward by gravity. To increase the amplitude of these harmonics, small weights are placed at intermediate locations on the connecting soft body between pairs of V-shaped legs. Each pair of soft legs is tuned to a natural resonance frequency, and when coupled in parallel through a central deformable elastic body, synchronization occurs between the legs during locomotion. In other words, after a transient period, each leg pair will converge to a similar limit cycle, but with a unique phase offset relative to its neighbors.

The objective of this study is to reproduce the dynamics of the soft passive walker described in Suzumori et al. \cite{Suzumori2008Sep} using \textit{Sorotoki}. In the work of Suzumori et al. \cite{Suzumori2008Sep}, the material parameters of the soft passive walker were given as: Young's modulus $E_0 = 1.2$ (\si{\mega \pascal}), Poisson ratio $\nu_0 = 0.49$, and density $\rho_0 = 3600 \cdot 10^{-12}$ (\si{\kilo \gram \per \milli \metre \cubed}). Since the material model is not exactly specified in \cite{Suzumori2008Sep}, a Neo-Hookean model was utilized with Rayleigh damping $\zeta = 1.5$.

To design the geometry of the V-shaped soft legs, the \code{sStrut(V1,V2,W)} function was utilized. This function generates an element of the \code{Sdf} class, requiring two nodal positions \code{V1,V2} and the strut's width \code{W} as input. The function was used to assemble a pair of legs iteratively, using the union operator implemented as {MATLAB}'s '\code{+}' arithmetic. The legs were then horizontally repeated three times with a uniform spacing of $25$ \si{\milli \metre}. A coupling soft body was added, along with two weights at intermediate locations. The resulting SDF is first converted to an \code{.png} template and the imported in the \code{msh = Mesh('SDF.png','ElementSize',1.0)} to generate the finite element mesh. %The code for the implicit modeling routine is given below

% \begin{lstlisting}[style=matlab] 
% sdf = Sdf([]);
% for i = 1:numel(Pts)
%     sdf = sdf + sStrut(Pts{i,1},Pts{i,2},1);
% end

% R = sRectangle(2).rotate(pi/4);
% W = R.translate([25,11]) + R.translate([50,11]);

% sdf = sdf.repeat([25,0],3) + ... 
%         sStrut([12,11],[62,11],1) + W;

% sdf.export('SDF.png');        
% \end{lstlisting}

The mesh is then utilized to construct the finite element model, \ie, \code{fem = Fem(msh)}. The timestep for the implicit solver is set at $\Delta t = 0.33$ \si{\milli \second}, which is set using \code{fem.setTimeStep(dt)}. Instead of modeling the inclined surface, which would also require rotating the mesh, the direction of the gravitational acceleration vector is modified as follows: $g := \textrm{Rot}_y(\varphi) a_g$ with $\varphi = -\frac{\pi}{6}$ (rad). The gravitational acceleration is then added using the class function \code{fem.addGravity}. The inclined surface is modeled as a horizontal line SDF, which is used as a contact environment for the FEM model through the function \code{fem.addContact}. It should be noted that in Figure \ref{fig:C5:passivewalker_true}, the soft walker is held in place by two fingers, which results in initial deformations of the soft body and nonzero initial conditions for the dynamic locomotion. To account for this, the mesh is pinned at the grasp locations, and the initial quasi-static deformations are solved for using \code{fem.solve}. Finally, the forward dynamics are solved implicitly using a Newmark-$\beta$ solver by calling the routine \code{fem.simulate}.

%
\begin{figure}[!t]
    \centering
    \includegraphics*[width=.99\textwidth]{./pdf/thesis-figure-6-19-1.pdf}
    %\includegraphics*[width=.495\textwidth]{./pdf/thesis-figure-6-19-2.pdf}
    %\input{./fig/fig_passivewalker_exp0.tex}
    \caption{Comparison of the front leg rectilinear displacement between the experimental data obtained from Suzumori et al. \cite{Suzumori2008Sep} and the numerical data produced by \textit{Sorotoki} shows that, although there are discrepancies, the step-like behavior and the traveled distance in the horizontal and vertical directions appear to be truthfully captured in comparison to the original experimental data. }
    \label{fig:C5:passivewalker_compare}
\end{figure}
%

Figure \ref{fig:C5:passivewalker_soro} shows snapshots of the dynamic simulation of the soft passive walker at times corresponding to those depicted in Figure \ref{fig:C5:passivewalker_true}. Although slight deviations are noticeable, the overall dynamic characteristics of the locomotion are captured closely by the dynamic FEM model produced using \texttt{Sorotoki}. To further demonstrate the validity of the model, a comparison of the rectilinear displacement of the front leg between the experimental data and the simulated model is presented in Figure \ref{fig:C5:passivewalker_compare}. The experimental data is obtained from \cite{Suzumori2008Sep} and is shown in Figure \ref{fig:C5:passivewalker_compare} (in gray). As demonstrated in the figure, the step-like behavior is accurately captured by the numerical model, and the horizontal and vertical distances traveled by the numerical model closely match the original experimental data.

To examine the gait cycle, we introduce state variables $\theta_1, \theta_2, \theta_3$ to represent the joint angles between the V-shaped legs, as depicted in Figure \ref{fig:C5:passivewalker_states}. The trajectory of these angles over a small time window of 200 \si{\milli \second} is shown in Figure \ref{fig:C5:passivewalker_gait}. The angular movements exhibit a clear and consistent "stable" gait cycle, indicating that synchronization indeed occurs between the deformable soft legs due to their interaction with the deformable soft body. An analysis of the stable gait cycle reveals a gait period of approximately $T_{\textrm{gait}} \approx 47.5$ \si{\milli \second} or $f_{\textrm{gait}} \approx 21.1$ \si{\hertz}.
%
\begin{figure}[!t]
    \centering
    \def\svgwidth{0.65\textwidth}
    %\input{./pdf/thesis-figure-6-20.pdf_tex}
    \input{./fig/walker_states.pdf_tex}
    \caption{Definition of the angular deflection of the three pairs of soft legs, denoted by $\theta_1$, $\theta_2$, and $\theta_3$, respectively. It should be noted that each pair has an intrinsic V-shaped structure, thus their stable equilibrium position during rest is approximately $\theta_i^\star \approx 45$ \si{\degree}. Raw image obtained from \cite{Suzumori2008Sep}.}
    \label{fig:C5:passivewalker_states}
    \vspace{-2mm}
    \end{figure}
    %
    \begin{figure}[!t]
        \input{./fig/fig_passivewalker_theta.tex}
        \input{./fig/fig_passivewalker_theta_gait.tex}
        \caption{Angular deflection of the V-shaped structure of the soft passive walker, simulated with Sorotoki. A clear gait cycle is observed in these deflections, indicating synchronization between the deformable structures due to the coupling of the soft body. By analyzing the stable gait cycles, a gait period of approximately $T_{\textrm{gait}} \approx 47.5$ \si{\milli \second} or $f_{\textrm{gait}} \approx 21.1$ \si{\hertz} is found.}
        \label{fig:C5:passivewalker_gait}
        \vspace{-6mm}
    \end{figure}
%
The numerical simulations presented in this study have effectively demonstrated the capabilities of the  \texttt{Sorotoki} framework in accurately capturing the complexities commonly encountered in dynamic analysis of soft robots. Furthermore, it has been demonstrated that the methodology proposed by Suzumori et al. \cite{Suzumori2008Sep} can be efficiently replicated using a minimal amount of code, specifically, approximately 30 lines within the \texttt{Sorotoki} framework.

\subsection{Computational design of bending PneuNet actuator}
In this section, we demonstrate the use of finite element models to aid in the design of PneuNet actuators, a popular type of soft robot actuator. PneuNet actuators, which have been in use since the 1980s, utilize a rectangular-shaped actuator with a stiffness differential to achieve a bending motion. Recent developments in the field, such as the work of Mosadegh et al. \cite{Mosadegh2014} and Ilievski et al. \cite{Ilievski2011Feb}, have proposed modern variations of PneuNet actuators that incorporate an inextensible but flexible bottom layer to further enhance the bending motion. The motion of a soft actuator depends on the interaction between the soft material, structural geometry, and the locations where external loads are applied. In their work, Mosadegh et al. \cite{Mosadegh2014} demonstrated the importance of geometry in the performance of PneuNet actuators by proposing a new design, called the fast PneuNet (fPN), that improved upon the earlier slower PneuNet (sPN) designs presented in \cite{Ilievski2011Feb}. The fPN design requires less gas for inflation and thus significantly increases the actuator's performance. Design optimization for PneuNet soft actuators remains an active area of research, as evidenced by recent studies \cite{Smith2022,Raeisinezhad2021May}.This demonstrates the continued interest in desing optimizing in soft PneuNet actuators, even decades after its initial development.

The purpose of this example is to demonstrate the use of Sorotoki's design capabilities to optimize and create a PneuNet actuator. We will apply an inverse design method to find the optimal configuration of a soft material that undergoes pure bending when pressurized. This approach extends upon the work presented in Chapter \ref{chap: design}. To extend of our prior study, we aim to show that the optimized designs produced through this computational design method can effectively overcome the Sim2Real hurdles. To find the optimal material arrangement, we will use a nonlinear topology optimization technique, specifically designed for compliant mechanisms.

The objective in the nonlinear topology optimization approach is to find the optimal material distribution $\vec{\rho}^\star = \textrm{argmin}_{\vec{\rho}}  -\vec{L}^\top \vec{x}(\vec{\rho})$, where $\vec{L}$ is a sparse unit vector that selects the nodal displacements that promote bending motion. Once an optimum is found, the material distribution $\vec{\rho}^\star$ can be transformed into a 3D model and manufactured using a commercial 3D printing platform, such as Elastic 80A resin (Formlabs). The optimization algorithm can take into account the specific mechanical properties of the selected printing material, allowing for an optimal design that is tailored to these material properties.
%
\begin{figure}[!t]
    \vspace{-2mm}
    \centering
    \includegraphics*[width=.95\textwidth]{./pdf/thesis-figure-6-22.pdf}
    %\input{./fig/fig_opt_solutions.tex}
    \caption{Evolution of the topology-based optimization routine in Sorotoki. At $k=0$, we see the initial guess for the PneuNet actuator, and at $k=100$ we see a converged solution of the optimizer. Observe that the algorithm proposes a solution very similar to the PneuNet, but instead, it has a teardrop shape rather than the classical rectangular shape. It is worth mentioning that the optimizer accounts for the hyper-elastic material properties - in this case, Elastic 80A resin by Formlabs.}
    \label{fig:C5:fig_optpneunet_solutions}
    \vspace{-3mm}
\end{figure}

\begin{figure}[!t]
    \centering
    %\input{./fig/fig_optpneunet_fem.tex}
    \includegraphics*[width=.95\textwidth]{./pdf/thesis-figure-6-23.pdf}
    \caption{Nonlinear finite element simulation of the optimized PneuNet actuator using \texttt{Sorotoki}. The system is subjected to a linear ramp upto 80 \si{\kilo \pascal}, and we observe the classical bending behavior of PneuNet actuators. The Von Mises stresses are shown as \protect\colormapcaption{0}{.75cm}$\!\!\in [0,10]$ \si{\mega \pascal}. }
    \label{fig:C5:fig_optpneunet_fem}
    \vspace{-3mm}
\end{figure}
%

To simplify the problem, we consider a single pressure chamber of the PneuNet actuator. To do this, a rectangular design domain with a size of $15 \times 30$ \si{\milli \meter} is defined using a \code{Sdf} library within Sorotoki. The \code{Mesh} class is then utilized to generate a mesh, which is used to construct a finite element model (FEM) using the \code{Fem} class. The \code{Fem} class takes several arguments to set up the optimization solver conditions, including the volume infill, penalty value, filter radius, time steps, and the maximum number of iterations for the method of moving asymptotes (MMA).

%
% \begin{lstlisting}[style=matlab] 
% fem = Fem(msh,'Infill', 0.33, 'Penal', 4, ... 
%     'FilterRadius', 2, 'TimeStep', 1/30, ... 
%     'MaxIterationMMA',70,'ChangeMax',0.05, ...
%     'OptimizationProblem','Compliant');
% \end{lstlisting}
%
The initial material distribution is set using \code{fem.initialTopology(sdf)} with \code{sdf = sCircle(5,[7.5,15])}, which creates a hole in the center of the actuator. The center element of the mesh is designated as an invariant pressure input and influences neighboring elements that satisfy the void conditions (i.e., $\rho_i \le \varepsilon$ with $\varepsilon = 0.1$) using an efficient flood-fill algorithm. The influenced void elements undergo synchronous volumetric expansion to simulate a positive pressure load. Given its similarities to muscular contraction, the syntax for this function is added as \code{fem.addMyocyte}. The material properties of the Elastic 80A resin from Formlabs are then specified using \code{fem.Material = Elastic80A}. Boundary conditions are added to the FEM model using the syntax \code{fem.addSupport}. Finally, the optimization routine is started using the \code{fem.optimize} command. %A code snippet is shown below:

% \begin{lstlisting}[style=matlab] 
% % ------------------------------------------------
% fem = Fem(msh,'TimeSteps',1/60);

% fem.Material = Elastic80A;
% fem = fem.initialTopology(sCircle(5,[7.5,15]));

% fem = fem.addSupport('Left',[1,1]);
% fem = fem.addSpring('Right',[0,1e-3]);
% fem = fem.addOutput('Right',[0,1]);
% fem = fem.addMyocyte('Center', 10 * kpa);

% fem = fem.optimize('Compliant',... 
%                    'MaxIteration', 100, ...
%                    'VolumeInfill', 0.3);
% % ------------------------------------------------
% \end{lstlisting}

The evolution of the material distribution during the first 100 optimization steps is depicted in Figure \ref{fig:C5:fig_optpneunet_solutions}. These interpolated isosurfaces are taken from the discrete FEM mesh and show the intermediate design solutions. Surprisingly, the optimization algorithm generates a design that is reminiscent of the fast PneuNet design presented by Mosadegh et al. \cite{Mosadegh2014}, but with a bellows-shaped pressure chamber in the form of an upside-down teardrop shape.

Next, the focus shifts to validating the optimization results. The aim is two-fold: $(i)$ to validate that the optimization algorithm indeed produces the desired bending motion, and $(ii)$ to verify if the design suggestion can be successfully transferred to reality (Sim2Real). To do this, the results of the optimization from \code{fem.optimize} are converted into a triangular mesh using \code{msh = fem.exportMesh}. Then, boundary conditions are assigned, such as a clamped boundary, gravitational loads, and internal pressure loads for each embedded PneuNet chamber. The same material model for \code{Elastic80A} resin is chosen. The quasi-static FEM simulation results of the optimized PneuNet actuator for linearly increasing pressure loads of $u = 80$ \si{\kilo \pascal} are shown in Figure \ref{fig:C5:fig_optpneunet_fem}. As can be seen, the desired bending behavior is achieved in the simulation.

\begin{figure}[!t]
    \centering
    %\input{./fig/fig_optpneunet_exp.tex}
    \includegraphics*[width=.825\textwidth]{./pdf/thesis-figure-6-24.pdf}
    \caption{Validation study of a 3D-printed \textit{PneuNet} actuator optimized using \textit{Sorotoki}. The soft actuator is printed using SLA on a Form3+ printer using Elastic 50A UV-resin. Similar to the numerical simulations, we vary the pressure from 0 to 80 \si{\kilo \pascal} with a linear ramp. To measure the planar displacement, an orange marker is placed such that \textit{Vision.m} can be employed.}
    \label{fig:C5:fig_optpneunet_exp}
\end{figure}

Next, the optimized isosurface shown in Figure \ref{fig:C5:fig_optpneunet_solutions} can be transformed into a 3D CAD model and printed as a physical soft actuator using a Form3+ SLA printer (FormLabs) with Elastic 80A resin. To validate its performance, the soft actuator is subjected to a linearly increasing pressure load of 80 \si{\kilo \pascal} in 5\si{\second} window. As seen in Figure \ref{fig:C5:fig_optpneunet_exp}, the optimized soft actuator successfully performs the desired bending motion, indicating the feasibility of crossing the Sim2Real barrier.

To quantify the discrepancies between the FEM predictions and the actual system, an optical marker is placed at the tip of the soft actuator. The spatial coordinates of the optical marker are obtained using the \class{Vision} class of \textit{Sorotoki}, which uses the color-filtered Hough-space circle transformation to return the pixel coordinates of the marker. These measurements are collected using a RealSense D435 RGB-depth camera (Intel). To retrieve the spatial location of the color marker, we use the command \code{cam = Vision('realsense')} together with the function \code{cam.getMarker(R,rgb)}, where \code{R} is an estimate of the color marker radius in pixels, and \code{rgb} is the RGB color value of the marker.

\begin{figure}[!t]
    \centering
    %\input{./fig/fig_opt_compare.tex}
    \includegraphics*[width=.8\textwidth]{./pdf/thesis-figure-6-25.pdf}
    \caption{Comparison between the numerical simulation in Sorotoki and the experimental results where the orange marker is tracked using the Vision.m class is shown. The Von Mises stresses are shown as \protect\colormapcaption{0}{.75cm}$\!\!\in [0,10]$ \si{\mega \pascal}. The results indicate a close overall trend between the simulation and experiment. However, a discrepancy in the initial deformation ($u - 0$ kPa) is observed. It is hypothesized that this discrepancy is attributed to the inherent creep of SLA resin materials, which leads to a predeformed continuum due to the slow relaxation of the material upon actuation. }
    \label{fig:C5:fig_optpneunet_exp_compare}
\end{figure}

The comparison between the FEM predictions and experimental results is presented in Figure \ref{fig:C5:fig_optpneunet_exp_compare}. The deformation patterns of the FEM model and the physical system show close agreement, with an average error of $\pm 2$ \si{\milli \meter}. However, there is a noticeable difference in the initial conditions, as shown in Figure \ref{fig:C5:fig_optpneunet_exp_compare}. For $u = 0$ \si{\kilo \pascal}, under pure gravitational loads, the deformations deviate significantly. The cause of this discrepancy is believed to be related to post-curing and internal stress relaxation of the photopolymerization process. This suggests that the stress-free configurations of the FEM model and the physical system may differ, but accounting for this stress-relaxation phenomenon in photopolymer printing is outside the scope of this study and the Sorotoki toolkit.

Despite the presence of some differences, the numerical and experimental examples presented in this study highlight the ability of the computational design framework within Sorotoki to generate purposeful and useful material distributions with limited prior knowledge of conventional soft robotic design practices. This not only speeds up the design process, but it also opens up the possibility of creating new and innovative soft robot forms.

\subsection{Dynamic manipulation of high dexterity soft gripper}
\label{sec:C5:suzumori_gripper}
In this section, we will examine the use of reduced-order models for soft beams within the context of the \textit{Sorotoki} software. These models are designed for efficient simulation by exploring minimal state representations of the dynamics of continuum systems. To demonstrate the capabilities of the soft beam modeling framework within Sorotoki, we will consider a specific example of a soft robotic system proposed by Suzumori and Suzuki in their seminal work \cite{Suzumori1991,Suzumori1992}. Despite being published in the early 1990s, the work by Suzumori et al. is still recognized as a seminal contribution to the field of soft robotics technology and remains relevant to this day.

In their research, Suzumori et al. developed a highly dexterous soft gripper consisting of four microfluidic soft actuators driven by an electro-pneumatic control system. Each finger has three internal pressure chambers, which together provide three controllable degrees of freedom at the fingertip, including pitch, yaw, and linear stretch. Unlike classic rigid grippers, the soft body of the gripper conforms to external forces, enabling intrinsic adaptation during grasping or manipulation tasks. As an illustration of the static grasping capabilities of this soft gripper, Figure \ref{fig:C5:suzumori_gripper_grasp} depicts two grasping configurations: a pinch grasp for a 40 \si{\milli \meter} diameter glass beaker (left) and a two-finger pair-pinch grasp for a 5 \si{\milli \meter} thick metal wrench (right). Suzumori et al. then employed inverse kinematic and compliance control to relate the tip position and compliance to input pressure values. As shown in Figure \ref{fig:C5:suzumori_gripper_grasp}, they were able to successfully hold and turn a 10 \si{\milli \meter} hexagonal bolt, with an average speed of 0.25 revolutions per second. Due to the wide range of dexterous actions performed by the gripper, the soft gripper proposed by \cite{Suzumori1991,Suzumori1992} remains a seminal contribution to the field of soft robotics, demonstrating the potential of the technology.
%
\begin{figure}[!t]
    \centering
    \includegraphics*[width=0.75\textwidth]{./pdf/thesis-figure-6-26-1.pdf}
    \includegraphics*[width=0.75\textwidth]{./pdf/thesis-figure-6-26-2.pdf}
    %\input{./fig/fig_suzugripper_old.tex}  \\[0.5em]
    %\input{./fig/fig_suzugripper_soro.tex}
    \caption{(top) Pinch and pair-pinch grasping configurations of the soft gripper proposed by Suzumori et al. \cite{Suzumori1992, Suzumori1991}. The high compliance of each soft finger allows for an adaptive, stable grasp that conforms to the shape of the rigid object. (bottom) A reconstructed soft gripper using the Sorotoki framework. To model each soft finger, we utilized the \class{Shapes} class and composed the entire gripper using the \class{Model} class. The rigid objects were modeled using the \class{Sdf} class. We observed a close resemblance between our simulation model and the original experiments performed by Suzumori et al. in \cite{Suzumori1991, Suzumori1992}.}
    \label{fig:C5:suzumori_gripper_grasp}
    \vspace{-3mm}
\end{figure}

The objective of this investigation is to replicate the static grasping and dynamic bolt-screwing experiments as conducted by Suzumori in their published works \cite{Suzumori1991, Suzumori1992}, utilizing the \class{Sdf}, \class{Shapes}, and \class{Model} classes available in the \textit{Sorotoki} software. The soft gripper's design specifications are based on the parameters provided by the available literature, which comprise a radius of $R_0 = 6$ (\si{\milli \meter}) and an assumed length of $L_0 = 80$ \si{\milli \meter} for each finger. Although the properties of the soft gripper's material are not mentioned explicitly, we suggest a Neo-Hookean model ansatz to address this issue. The proposed model has an elasticity modulus of $E_0 = 1.0$ \si{\mega \pascal}, Poisson ratio of $\nu_0 = 0.3$, and density of $\rho_0 = 2000 \cdot 10^{-12}$ \si{\kilo \gram \per \milli \metre \cubed}. The reduced-order model for each soft finger in interaction with a rigid object, denoted by $\Sigma_{\textrm{SR},i}$, is described by the following equation:
%
\begin{multline}
    \vec{M}(\q_i) \ddot{\q}_i  + \hB(\q_i,\dq_i)  =  \GB(\q_i) \pB_i +  \sum_{j\in \mathcal{S}_{\Omega_{\textrm{env}}}} \JB_{v,j}^\top(\q_i) \Big[ \FT_{{n},j}(\q_i) + \FT_{{t,j}}(\q_i,\dot{\q}_i)\Big],
    \label{eq:suzumori_fingermodel_lagrangian}
\end{multline}
%
where $\hB(\q_i,\dq_i)$ represents the collection of nonlinear internal forces, $\pB_i$ is the prescribed pressure input, $\JB_v(\q):= \lfloor\JB(L,\q)\rfloor_3$ is the linear velocity part of the generalized Jacobian matrix of the tip, $\mathcal{S}_{\Omega_{\textrm{env}}}$ represents the nodal indices that penetrates the object, and $
\FT_{{n}} = -\mu_e d \cdot \vec{e}_n$ and $\FT_{{t}} = -\mu_v |\FT_{{n}}| \, \textrm{sign}(\dot{d}) \cdot \vec{e}_t$ 
denoting the normal and tangent contact forces between the $i$-th finger and the rigid object, respectively. The parameters $\mu_e, \mu_v > 0$ represent the contact coefficients. The distance between the finger and the object is given by $d = \texttt{sdf}_{\Omega_{\textrm{env}}}(\gammaB_L(\q))$, where $\texttt{sdf}_{\Omega{\textrm{env}}}(\cdot)$ represents the signed distance function of the rigid object and $\gammaB_L(\q)$ the finger's tip position. 

In this study, we utilize a third-order Chebyshev polynomial basis to model the deformation of the pneumatic soft robot's finger. The basis is sampled over $N_p = 100$ uniform nodes and is assembled into a matrix using the command \code{pod = Basis(100,3,'chebyshev')}. It is assumed that only free strains occur in the bending, while elongation and torsion are neglected. Each strain mobility vector is characterized by three modes of the Chebyshev basis, specified as \code{dof = [0,3,3,0,0,0]}, leaving the $\kappa_x$ and $\kappa_y$ curvatures free. The dynamic model for each finger is constructed using the command \code{shp = Shapes(pod,dof)}. The material properties are assigned using \code{shp.Material = NeoHookean(1.0, 0.3)}. To set the geometry of each finger, we call \code{shp.setLength(80)} to set its length, and \code{shp.setGeometry(sCircle(6))} to set a circular cross-section of radius $6$ (mm). Each finger of the soft gripper model is equipped with three fluidic chambers that are radially distributed along its circumference. As such, the input map $\GB$ for each finger becomes a nonlinear, non-square matrix. We assume that these distributed forces can be represented by a tangent bundle of linear forces that are positioned $3$ (mm) away from the center axis. To assign these forces, the \code{shp.addFluidic(@p)} command can be utilized, which requires an anonymous function \code{@p} that describes the path of the soft actuator. %A sample code for assembling one soft finger model is given below.

% \begin{lstlisting}[style=matlab] 
% dof = [0,3,3,0,0,0];
% pod = Basis(100,5,'chebyshev');

% shp = Shapes(pod, dof);
% shp = shp.setLength(80);
% shp = shp.setGeometry(sCircle(6));
% shp.Material = NeoHookeanMaterial(1.0, 0.3, ... 
%                 'Rho', 2000 * 1e-12);

% % for loop to assemble fluidic chambers
% for ii = 1:3
%     phi  = (ii - 1) * pi / 3
%     path = @(s)  3.0 * [cos(phi); sin(phi); s];
%     shp  = shp.addFluidic(path); 
% end

% shp = shp.rebuild(); % pre-assemble
% \end{lstlisting}

The full soft gripper model, composed of four identical finger \textit{Shapes} classes, can be assembled using a for-loop routine. In this process, a class representing each finger is copied and assigned a unique $\textrm{SE}(3)$ base frame to each instance. Each finger is placed in a circular array with a radius of 37.5 (mm) relative to the center axis of the gripper body. The contact domain for each finger is specified using the method \code{shp.addContact(sdf)}, where \code{sdf} denotes the signed distance field of the contact object. For the beaker example, a cylindrical SDF with dimensions $40 \times 40 \times 60$ (mm) is considered, while for the wrench, a rectangular SDF with dimensions $5 \times 10 \times 100$ (mm) is used. Subsequently, each instance of the \class{Shapes} class is appended to the \class{Model} class constructor using the \code{mdl.addSystem(shp)}.

Once the global model of the soft gripper has been assembled, it can be controlled using an open-loop controller. In the case of a static grasping scenario with a glass beaker and wrench, we apply pressure ramps to each pressure chamber of the soft gripper through an auxiliary anonymous function, \code{@(mdl) Control(mdl)}. The function takes in a time variable and outputs a column vector of pressure signals, represented by $\vec{u} = (\vec{p}_1, \vec{p}_2, \vec{p}_3, \vec{p}_4)^\top$. The controller is then assigned to the Model class using the command \code{mdl.addControl(@Control)}, which is executed at each simulation step. The forward dynamics of the soft gripper's interaction with the object are implicitly solved through the \code{mdl.simulate()} routine. The simulated grasping configurations are shown in Figure \ref{fig:C5:suzumori_gripper_grasp}. It is evident that there is close agreement with the experiments in \cite{Suzumori1991,Suzumori1992}.

Subsequently, we aim to reproduce the hexagonal bolt screwing experiment of \cite{Suzumori1992,Suzumori1991}, which involves a more complex simulation than the previous scenario due to the dynamic interaction between the environment and the soft robot. To accurately depict this interaction, we must also incorporate dynamics into the signed distance field describing the hexagonal bolt screw. We assume a rotational mass-damper system, represented by the following equation:
%
\begin{align}
    I_\Omega\,\ddot{\theta} & = -\mu_\Omega \dot{\theta} -\sum_{i=1}^{N_{\textrm{finger}}} \!\!\sum_{j \in \mathcal{S}_\Omega} \rB_j (\q_i) \times \FT_{t,j}(\q_i,\dot{\q}_i) \cdot \vec{e}_3,                                                                      
    \label{eq:C5:screw}
\end{align}
%
where $I_\Omega = $ is the inertia of the hex-bolt, $\mu_\Omega = 2.5$ its friction coefficient, and $\rB$ the relative position vector from the point of contact and the central turning axis of the screw. Note that we only include the tangential force components $\FT_t$ that are responsible for motion, as the normal forces are assumed to have a net zero-torque contribution. The model described in equation \eqref{eq:C5:screw} is incorporated into the simulation by using the command \code{mdl.addSystem(@f)}, where \code{@f(x,u,t)} is an anonymous function that represents the state space. The required input \code{u} for equation \eqref{eq:C5:screw} is connected to the soft gripper by utilizing the \code{mdl.addController(@Controller)} command, which inputs tangential reaction forces into the screw model. The controller also includes the prescribed pressure profile $\pB_{1,2,3,4}$ for each of the four soft fingers.\\
%
% \begin{rmk}
% The inertia of the steel bolt $I_\Omega$ has been derived using standard ISO metric profiles of M10 screws. The screwing friction, however, has be determined using an ad-hoc approached, where the parameter has been tuned until desired behavior appears.\\
% \end{rmk}
% %

\afterpage{
\begin{figure*}[!t]
    \centering
    \includegraphics*[width=.85\textwidth]{./pdf/thesis-figure-6-27.pdf}
    %\input{./fig/fig_suzugripper_screw_old.tex} \\[0.5em]
    %\input{./fig/fig_suzugripper_screw_simulation.tex}
    \caption{(top) Snapshots of the bolt screwing experiment with the soft gripper, as presented in the work of Suzumori et al. \cite{Suzumori1991,Suzumori1992}, are displayed. The soft gripper periodically switches through a predefined set of configurations, enabling the holding and manipulation of a hexagonal bolt screw. In the experiment, a bolt turning rate of 0.25 rps was achieved. (bottom) The bolt screwing experiment was reproduced using \texttt{Sorotoki}. In the simulation, each finger was modeled utilizing the class \class{Shapes} and assembled together into \class{Model}. The contact interaction with the bolt was modeled using signed distance functions, and a rotational mass-damper model was used to describe the dynamics of the bolt. By utilizing solely the frictional interaction between the fingers and the screw, the experiment of Suzumori et al. was successfully reproduced.}
    \label{fig:C5:suzumori_gripper_screw}
    \vspace{-3mm}
\end{figure*}
\clearpage
}

%
\begin{figure}[!b]
    \centering
    \vspace{-3mm}
    \includegraphics*[width=.95\textwidth]{./pdf/thesis-figure-6-28.pdf}
    %\input{./fig/fig_suzugripper_screw_plot.tex}
    \caption{The evolution of the hexagonal bolt angle $\theta(t)$ is depicted, where the stair-like trajectory of the screwing motion, as observed in Suzumori's experiment, is apparent. Through careful parameter and input shaping, a bolt-screwing motion of 0.16 rps was achieved. This is slightly slower than the reported rate of 0.25 rps, however, the underlying morphological characteristics are accurately captured.}
    \label{fig:C5:suzumori_gripper_screw_states}
\end{figure}

The qualitative comparison between the experiments conducted by Suzumori et al. \cite{Suzumori1991,Suzumori1992} and our numerical model programmed using \textit{Sorotoki} is depicted in Figure \ref{fig:C5:suzumori_gripper_screw}. Similar to the simulation of the static object grasping scenario, the simulation of the Suzumori soft gripper's screwing experiment qualitatively reflects the real-world experiment performed in the 1980's. Not only do we observe similar deformation characteristics in the soft finger, but we also observe the step-like turning of the bolt screw, as reported in \cite{Suzumori1992}. To highlight these rotational trajectories, we present the rotation angle $\theta(t)$ in Figure \ref{fig:C5:suzumori_gripper_screw_states}, which shows that an average bolt-screwing speed of 0.16 rps is achieved. Although this rate is slightly slower than the reported rate of 0.25 rps, it is believed that the underlying morphological characteristics are accurately captured. Note that although the system is of highly complex nature, the simulation program contains less than 100 lines of code (including visualization).

\subsection[Environmental impedance control of soft manipulator]{Impedance control of soft robot manipulator with static environmental interaction}
The subsequent section will focus on the development of controllers utilizing the \class{Model} and \code{shapes} classes. In prior experiments, the Suzumori et al. gripper was governed in an open-loop fashion, with complications arising from the interplay between the model and dynamic object. Our investigation will now examine the feasibility of model-derived controllers in the \texttt{Sorotoki} scenario, drawing upon Della Santina et al.'s work \cite{DellaSantina2020a} as a prospective case study.

Their work presents a design for model-based controllers for soft robot manipulators, highlighting two control architectures: dynamic tracking and surface tracking. The authors proposed a Cartesian impedance controller for the latter architecture, which actively regulates the desired compliance behavior of the soft robot's end-effector in a static environment. Additionally, the work presented a contact path planning algorithm that initially brings the robot close to a desired setpoint on the surface (Phase 1: Approach), and then adjusts the setpoint to maintain contact with the surface (Phase 2: Explore). The proposed controller was validated both numerically and experimentally on a six-link soft robot manipulator, demonstrating that model-based controllers can lead to higher-level performances in soft robotic systems.

To maintain high computational bandwidth, the impedance controllers used in Della Santina et al.'s study \cite{DellaSantina2020a} incorporate an augmented rigid body model. This model employs Constant-Curvature kinematics to approximate the center of mass of the continuously deformable robot by projecting its mass distribution into a lumped mass description. This leads to an Euler-Lagrangian representation similar to the commonly used Denavit-Hartenberg (DH) parametrization models in rigid robotics. Moreover, this approach maintains classical properties, such as positive semi-definiteness of the inertia matrix and passivity properties, which are valuable for stability analysis.

Our aim in this section is to replicate the results of the closed-loop controlled multi-link soft robot during dynamic contact that were presented in the study by Della Santina et al. \cite{DellaSantina2020a}. Instead of employing the augmented rigid body model used in their work, we explore a reduced-order beam model, in which each link is represented as an inextensible, continuous PCC segment. This approach extends their work to a distributed mass robotic system. As a template for the soft manipulator model, we again utilize the \class{Shapes} class. According to \cite{DellaSantina2020a}, each CC segment of the soft manipulator has an intrinsic length of $\delta L_0 = 60$ (mm) and a mass of $m_0 = 334$ (g). The robot has a rounded rectangular cross-section of 60 $\times$ 20 (mm), which is described using \code{sdf = sSquircle}. The density of the soft robot manipulator, given its length and geometry, is approximated to be $\rho_0 = 1200 \cdot 10^{-12}$ (\si{\kilo \gram \per \milli \metre \cubed}). 

A crucial aspect of the simulation is the dynamic interaction with the environment. Therefore, a static environment must be assigned to the dynamic model. While \cite{DellaSantina2020a} presents multiple examples of dynamic contact, this study focuses on the experiment with a 40$^\circ$ slanted surface with wave indentations, as shown in Figure \ref{fig:C5:dellasantina_experiment}. The surface features were extracted from the image data presented in \cite{DellaSantina2020a} and the \code{env = sPolyLine(V)} function was used to generate the SDF environment, where \code{V} is a polyline vector. The environment is then added using \code{Shapes.addContact(env)}. Once all settings are assigned to the class \class{Shapes}, the model is constructed by \code{mdl = Model(Shapes)}. %The code for assembling the dynamic model is given below:

% \begin{lstlisting}[style=matlab]   
%  dof = [0,6,0,0,0,0];
%  pod = Basis(100,6,'pcc');

%  shp = Shapes(pod, dof);
%  shp = shp.setLength(60 * 6);
%  shp = shp.setGeometry(sSquircle(3, 3, 0.25));
%  shp = shp.addContact(sPolyLine(V));
%  shp.Material = NeoHookeanMaterial(1.0, 0.3, ... 
%                  'Rho', 1200 * 1e-12);

%  % build model (calls rebuild automatically)
%  mdl = Model(shp);
% \end{lstlisting}

Given the \class{Model} class, we can now start deriving the control law. For conciseness, let $\JB(\q) := \JB(L,\q)$ be the geometric Jacobian of the end-effector. We also introduce the Cartesian inertia matrix as $\LambdaB := (\JB^\top \MB \inv \JB^\top)\inv$. Then, the proposed Cartesian stiffness controller given in \cite{DellaSantina2020a} can be written as:
%
\begin{multline}
    \tauB = \JB^\top \Big[\JB_M^{+\top} \fB_{e} + \fB_{g} + \JB^\top \etaB_{\CB}(\IB - \JB_M^{+\top}\JB)\dq  \JB^\top(\KB_{c} (\gammaB_d - \gammaB_L) - \DB_c \JB \dq) \Big ],
    \label{eq:C5:dellasantina_controller}
\end{multline}
%
where $\gammaB_d$ and $\gammaB_L$ represent the desired and true end-effector positions, respectively; and $\KB_c$ and $\DB_c$ are the desired stiffness and damping of the end-effector. The closed-loop controller employs a so-called \textit{"dynamically consistent pseudo-inverse"} of the Jacobian, denoted as $\JB_M^{+}$, which is defined as $\JB_M^{+} := \MB^{-1} \JB^\top \LambdaB$. The controller also utilizes the Cartesian Coriolis terms, denoted as $\etaB_{\CB}(\q,\dq)$, which are expressed in the Cartesian frame and given by:
%
\begin{equation}
    \etaB_{\CB} = \LambdaB (\JB \MB\inv \CB - \dot{\JB})
\end{equation}
%
The closed-loop controller, implemented as an anonymous function, is derived from four system matrices: the inertia matrix $\MB(\q)$, the Coriolis matrix $\CB(\q,\dq)$, the Jacobian $\JB$, and its time derivative $\dot{\JB}$. In \textit{Sorotoki}, these matrices are automatically computed at each solver step and stored in a data structure named \code{shp.log}. The closed-loop controller can access this data structure. %A sample code of the controller is provided below:
%\vfill

% \begin{lstlisting}[style=matlab] 
% % ------------------------------------------------    
% function tau = Control(mdl)
%     % retrieve current log
%     log = mdl.System{1}.log;

%     J  = log.FK.J(:,:,end);        
%     dJ = log.FK.dJdt(:,:,end); 
    
%     Mi  = inv(log.EL.M);
%     Lam = inv(J * Mi * J.'); 
%     Eta = Lam * (J * Mi * log.EL.C - dJ);
%     Jmi = Mi * J.' * Lam;

%     if mdl.System{1}.isContact()
%         xd = [0.3637; 0.1406];
%     else
%         xd = [0.2307, 0.2576];
%     end

%     % impedance controller
%     tau = J.' * (Jmi.' * fe + fg + ... 
%         Eta * (log.I - Jmi.' * J) * log.dq + ...
%         (Kc * (xd - log.FK.p) - Dc * J * log.dq));
% end
% % ------------------------------------------------
% \end{lstlisting}

%
It is noteworthy that the controller above uses the command \code{shp.isContact} to detect if the robotic system is in contact. Similar to path planning in \cite{DellaSantina2020Jan}, upon contact, a new desired equilibrium position is adopted. These desired equilibrium positions for the end-effector are in line with the approach presented in \cite{DellaSantina2020a}. Subsequently, the implicit solver is invoked by calling \code{mdl.simulate} to solve the closed-loop dynamics. Snapshots of the dynamics have been presented in Figure \ref{fig:C5:dellasantina_experiment} which are produced by calling the function \code{shp.render}. Figure \ref{fig:C5:dellasantina_endeffector} shows the trajectory of the end-effector (dashed lines are the desired setpoints), Figure \ref{fig:C5:dellasantina_states} shows the evolution of the states, and Figure \ref{fig:C5:dellasantina_input} shows the control action $\tauB$ from \eqref{eq:C5:dellasantina_controller}.
%
\afterpage{
\begin{sidewaysfigure*}[!h]
    \centering
    \includegraphics*[width=0.95\textwidth]{./pdf/thesis-figure-6-29-1.pdf} \\[0.75em]
    \includegraphics*[width=0.95\textwidth]{./pdf/thesis-figure-6-29-2.pdf}
    %\input{./fig/fig_dellasantina_true.tex} \\[0.35em]
    %\input{./fig/fig_dellasantina_simu.tex}
    \caption{\small (top) The experimental results presented in the work of Della Santina et al. \cite{DellaSantina2020Jan} show a six-link soft manipulator controlled by the control law described in \eqref{eq:C5:dellasantina_controller}. The manipulator is in contact with a static environment. The controller first ensures that the soft robot approaches the environment (Phase 1: Approach) and then follows the rigid wavy surface (Phase 2: Explore). (bottom)  The numerical simulations performed using the \textit{Sorotoki} toolkit are inspired by the work of Della Santina et al. \cite{DellaSantina2020Jan}. In the simulation, the active setpoints are denoted by (\textcolor{Matlab2}{$\bullet$}) and the de-activated setpoints are denoted by (\textcolor{gray}{$\bullet$}). The end-effector trajectory is shown in \data{magenta} and the environment is shown in \data{Matlab1}. The results of the simulation truthfully reflect the approaching and surface tracking behavior as seen in the experiments.}
    \label{fig:C5:dellasantina_experiment}
    \vspace{-3mm}
\end{sidewaysfigure*}
}

\afterpage{
\begin{figure}[!t]
    \centering
    %\vspace{-20mm}
    \includegraphics*[width=0.8\textwidth]{./pdf/thesis-figure-6-30.pdf}
    %\input{./fig/fig_dellasantina_simu_EF.tex}
    \caption{\small The end-effector trajectories of the six-link soft manipulator, where $\{$\ldata{Matlab1}, \ldata{Matlab2}$\}$ denote the horizontal and vertical position, respectively. The setpoints assigned by the controller are indicated by the dashed lines. Note that at $t \approx 0.88$ (s), the point of contact, the controller switches setpoint. }
    \label{fig:C5:dellasantina_endeffector}
    \vspace{-3mm}
\end{figure}
%
\begin{figure}[!t]
    \centering
    %\vspace{-20mm}
    \includegraphics*[width=0.8\textwidth]{./pdf/thesis-figure-6-31.pdf}
    %\input{./fig/fig_dellasantina_simu_Q.tex}
    \caption{\small State evolutions of the six-link soft manipulator, where the states represent the planar curvature of each individual soft link. }
    \label{fig:C5:dellasantina_states}
    \vspace{-3mm}
\end{figure}
%
\begin{figure}[!t]
    \centering
    %\vspace{-20mm}
    \includegraphics*[width=0.8\textwidth]{./pdf/thesis-figure-6-32.pdf}
    %\input{./fig/fig_dellasantina_simu_U.tex}
    \caption{\small The control inputs $\tauB$ in (\si{\milli \newton \meter}) produced by the control law in \eqref{eq:C5:dellasantina_controller} exhibit a significant peak at the point of contact. This is due to two factors: $(i)$ the sudden change of setpoint and $(ii)$ the switch in control strategy to accommodate for compliance.}
    \label{fig:C5:dellasantina_input}
    %\vspace{-3mm}
\end{figure}
\clearpage
}

When comparing the experimental results reported by Della Santina et al. \cite{DellaSantina2020Jan} and the numerical simulations produced by \textit{Sorotoki}, we observe similar deformation characteristics in both systems. Most notably, the numerical implementation of the impedance Cartesian stiffness controller also follows the inclined surface until the setpoint is reached. These similarities highlight the reliability of Sorotoki in accurately reflecting true soft robotic systems, even in closed-loop scenarios. 

\subsection[Contact robust shape sensing of elastomer soft actuator]{Contact robust shape sensing of elastomer soft actuator (PneuNet) using a FEM-based modal basis}
In the next section, our focus shifts from simulation to the experimental domain. Our primary focus will be on the \class{Vision} and \class{Control} classes, and we aim to provide experimental validation for the Data-driven Variable Strain (DVS) basis approach detailed in Section \ref{sec:C5:femPODbasis}. The objectives of this study case are $(i)$ to derive a finite-dimensional Cosserat beam model of the PneuNet actuator and $(ii)$ to implement a real-time shape sensing algorithm that is robust against external forces through the exploration of model information.

We begin our investigation by conducting a nonlinear dynamics analysis of a soft PneuNet actuator, the geometry of which has been selected to match that described in the work of Mosadegh et al. \cite{Mosadegh2014}. The soft actuator is suspended vertically in order to produce minimal deformation under zero-input conditions. In pursuit of high-accuracy simulation, we first perform a Finite Element simulation. The generation of the mesh is performed using the function \code{msh = Mesh('PneuNet.png')}, which utilizes an image of a PneuNet cross-section as input. The finite element model is then formed using \code{fem = Fem(msh)}, and the appropriate material properties (\ie, Dragonskin10) and boundary conditions are assigned. The system is subjected to a linearly increasing and decreasing pressure ramp of $40$ (\si{\kilo \pascal}), and the dynamics are solved using \code{fem.simulate}. In accordance with the procedure outlined in Section \ref{sec:C5:femPODbasis}, a third-order DVS basis for pure bending is then constructed, which are used to construct the \class{Shapes} class. The curvature-bending modes are shown in Figure \ref{fig:C5:pneunet_modes_fem}. 
%

Given that the \class{Shapes} class has been constructed, we can now tailor the real-time estimation algorithm. This is achieved through the utilization of an inverse kinematics algorithm, as described in Section \ref{sec:C5:inverseKinematics}. The algorithm can be invoked using the function \code{Shapes.IK(pos, q0)}, where \code{pos} represents the desired position (such as a camera measurement) and \code{q0} is an initial estimate. The inverse kinematics solver is then repeatedly called in the real-time control loop. To ensure that the inverse kinematics solution aligns with the true system behavior, we also consider the null-space subtask projection. In this case, the gradient of the subtask is assumed to be $\nabla \Phi_{\textrm{sub}}(\q) = \KB \q + \fB_g(\q) - \GB(\q) u$, where $u = 30 \cdot \textrm{sat}\left[ \sin(t) \right]$ (\si{\kilo \pascal}) is the prescribed pressure input assigned by the open-loop controller. This subtask serves to minimize the internal residual forces -- and thus is nothing more than a quasi-static deformation solver that is guided by the camera measurements. Note that model parameter have been pre-tuned to align with the experimental system presented in Figure \ref{fig:C5:pneunet_estimate_experiment}. However, certain initial estimates of the system parameters have been used that are produced by the Finite Element model.

\begin{figure}[!t]
    \centering
    \includegraphics*[width=0.95\textwidth]{./pdf/thesis-figure-6-32-1.pdf} \\[0.25em]
    \includegraphics*[width=0.95\textwidth]{./pdf/thesis-figure-6-32-2.pdf}
    %\input{./fig/fig_pneunet_modes_plot.tex} \\[0.25em]
    %\input{./fig/fig_pneunet_modes.tex}
    \caption{\small (top) The first three DVS modes of the soft PneuNet actuator in vertical hanging condition, where the ordering is $\{$\ldata{Matlab1},\ldata{Matlab2},\ldata{Matlab3}$\}$. (bottom) The respective deformation for each strain mode of the PneuNet actuator. Note that these differ from the DVS basis in Section \ref{sec:C5:femPODbasis}.}
    \label{fig:C5:pneunet_modes_fem}
    \vspace{-3mm}
\end{figure}

\par To instantiate the camera class, we call \code{cam = Vision('realsense')} and establish a Secure Shell (SSH) connection with the control platform through \code{brd = Control('ip','pwd')}. Once the connection with the control platform is established, a real-time while-loop containing the necessary shape estimation algorithms to be executed. %The code for this process is provided below:

% \begin{lstlisting}[style=matlab] 
% while brd.loop(20)   % control-loop for 20 s

%     % set pressure signal
%     brd.setInput([Pressure(brd.t), 0]);
    
%     % real-time visualization
%     cam = cam.getFrame();
%     if isempty(h)
%         h = imshow(cam.lastFrame,.... 
%                    cam.WorldLimits); 
%     else
%         shp.FK(q,'Plot',true);
%         h.CData = cam.lastFrame;
%     end

%     % get color marker
%     cam = cam.getMarker(9);

%     % inverse kinematics solver
%     q = shp.IK(cam.output, q, ... 
%                'SubTask', @(s) gradPhi(s,p));               
% end
% % ------------------------------------------------
% function y = gradPhi(Shapes,p)
%   y = Shapes.Log.EL.fe + Shapes.Log.EL.fg ... 
%        - Shapes.Log.EL.G * p(1);
% end
% % ------------------------------------------------
% \end{lstlisting}

\afterpage{
\begin{figure}[!t]
    \centering
    \includegraphics*[width=0.8\textwidth]{./pdf/thesis-figure-6-34.pdf}
    %\input{./fig/fig_pneunet_estimate.tex}
    \caption{\small Real-time shape estimation using the \class{Shapes} inverse kinematics algorithm in combination with the Data-driven Variable Strain (DVS) basis. The reconstructed backbone curve is depicted in \data{magenta}. Despite the presence of substantial contact forces on the soft actuator, the shape estimation algorithm accurately reflects the behavior of the real soft robotic system. Due to the relatively small state dimension of $\dim(\q) = 3$, the algorithm achieves a bandwidth of +60 \si{\hertz}.}
    \label{fig:C5:pneunet_estimate_experiment}
    \vspace{-3mm}
\end{figure}
%
\begin{figure}[!t]
    \centering
    \includegraphics*[width=0.95\textwidth]{./pdf/thesis-figure-6-35.pdf}
    %\input{./fig/fig_pneunet_states.tex}
    %\vspace{-5mm}
    \caption{\small Evolution of the state estimations during the PneuNet experiment, where the ordering is given by $\{$\ldata{Matlab1},\ldata{Matlab2},\ldata{Matlab3}$\}$. Note that the joint variables represent the modal coefficients of the DVS basis related to curvature-bending. }
    \label{fig:C5:pneunet_estimate_experiment}
    %\vspace{-5mm}
\end{figure}
\clearpage
}

Figure \ref{fig:C5:pneunet_estimate_experiment} shows the experiment and overlayed on top are the real-time shape estimations from the inverse kinematics algorithm that uses a combination with the Data-driven Variable Strain (DVS) basis. Figure \ref{fig:C5:pneunet_estimate_experiment} shows the state trajectories and the time instance of contact. Despite the significant impact of contact forces on the soft actuator, the shape estimation algorithm qualitatively matches the deformation profile of the real soft robotic system. This is due to its relatively low state dimension of $\dim(\mathbf{q}) = 3$, enabling it to achieve a bandwidth of +60 \si{\hertz} with ease.
